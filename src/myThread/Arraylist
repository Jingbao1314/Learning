ArrayList 默认大小 10 底层是数组
扩容策略:*2
Vector可以简单的理解为对所有方法加了锁

LinkList 1.6 使用的是一个带有头结点的双向循环链表 1.7和1.8使用的是不带头结点的普通的双向链表，增加两个节点指针first、last分别指向首尾节点。
一个很小的优化，根据下标判断下哪种路径更短，该从头开始还是从尾部开始。
因为下标index是从0开始的，所以if (index < (size >> 1))这句是没有问题的，加上等号才有问题。

CurrentHashMap 默认大小16 底层用一个数组组织segment每一个segment属于一组每一组由多个k:v组成
CurrentHashMap在添加数据时会首先算出数据属于那一组(计算的算法是hashCode&mark),然后再计算属于这一组的那个位置
在添加元素时如果出现了冲突CurrentHashMap的解决办法是分离连接法将产生冲突的数据用链表的形式进行组织
jdk1.8当链表长度超过8的时候会将链表转化为红黑树
CurrentHashMap 的扩容策略*2(oldCapacity<<1) 扩容以后需要将相应的K:V放到响应的位置,不过好在不是全部
为什么说不需要移动所有的K:V
因为默认大小是16每次扩容都是2倍 所以每一组桶的大小都是2的幂次
获取序号的方式是
int idx = e.hash & sizeMask;
sizeMask=cap-1 (这个数转换为2进制刚好是全一的11......1)
设扩容以后的cap为2^K  原来的则是2^K-1
获取序号的算法是用元素的hash值与sizeMask做与的操作。这样得到的idx实际上就是元素的hashcode值的低k位的值。
而原table的sizeMask也全是1的二进制，不过总共是k-1位。那么原table的idx就是元素的hashcode的低k-1位的值。
所以说如果元素的hashcode的第k为如果是0，那么元素在新桶的序号就是和原桶的序号是相等的。
如果第k位的值是1，那么元素在新桶的序号就是原桶的序号+(2^k-1)。
